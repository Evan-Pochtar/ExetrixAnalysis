use anyhow::Context;
use serde_json::Value;
use std::env;
use std::fs;
use std::io::Write;
use std::path::PathBuf;
use std::process::{Command, Stdio};
use tempfile::tempdir;
use tera::Context as TeraContext;

const PROFILER_PY: &str = include_str!("profiler_wrapper.py");

fn detect_language(path: &str) -> &'static str {
    match PathBuf::from(path)
        .extension()
        .and_then(|s| s.to_str())
        .unwrap_or("")
    {
        "py" => "python",
        _ => "unknown",
    }
}

fn main() -> anyhow::Result<()> {
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <target_script> [args...]", args[0]);
        std::process::exit(2);
    }

    let target_script = &args[1];
    let language = detect_language(target_script);

    let exe_path = env::current_exe()?;
    let exe_dir = exe_path.parent().unwrap();

    let report_dir = exe_dir.join("../../report");
    if report_dir.exists() {
        println!("Cleaning previous report directory...");
        fs::remove_dir_all(&report_dir)?;
    }
    fs::create_dir_all(&report_dir)?;

    if language != "python" {
        println!("Detected language: {}. No profiler available for this language yet.", language);
        let report = serde_json::json!({
            "meta": {
                "language": language,
                "command": [target_script],
                "timestamp": chrono::Utc::now().timestamp(),
            },
            "nodes": [],
            "edges": [],
            "memory_samples": [],
            "cpu_samples": [],
            "gc_samples": [],
            "summary": {
                "note": "No profiler run. Only metadata generated by Rust."
            }
        });
        let report_path = report_dir.join("report.json");
        fs::write(&report_path, serde_json::to_string_pretty(&report)?)?;
        let html_path = report_dir.join("report.html");
        let html = format!(
            "<!doctype html><html><head><meta charset='utf-8'><title>Profile Report</title></head><body><pre>{}</pre></body></html>",
            serde_json::to_string_pretty(&report)?
        );
        fs::write(&html_path, html)?;
        println!("Report written: {}", report_path.display());
        println!("HTML written: {}", html_path.display());
        return Ok(());
    }

    let temp_dir = tempdir()?;
    let profiler_path = temp_dir.path().join("profiler_wrapper.py");
    {
        let mut f = fs::File::create(&profiler_path)?;
        f.write_all(PROFILER_PY.as_bytes())?;
    }

    let mut cmd = Command::new("python");
    cmd.arg(profiler_path.to_str().unwrap())
        .arg("--report-dir")
        .arg(report_dir.to_str().unwrap())
        .arg("--")
        .arg(target_script);

    for a in args.iter().skip(2) {
        cmd.arg(a);
    }

    cmd.stdin(Stdio::inherit())
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit());

    println!("Running Python script under profiler...");
    println!("   Script: {}", target_script);
    if args.len() > 2 {
        println!("   Args: {}", args[2..].join(" "));
    }
    println!();

    let status = cmd.status()?;
    if !status.success() {
        anyhow::bail!("Target process exited with {}", status);
    }

    let raw_path = report_dir.join("raw_profile.json");
    let raw_text = fs::read_to_string(&raw_path)
        .with_context(|| format!("expected raw profile at {}", raw_path.display()))?;
    let raw: Value = serde_json::from_str(&raw_text)?;

    let stats_map = raw
        .get("stats")
        .and_then(|v| v.as_object())
        .cloned()
        .unwrap_or_default();

    let mut nodes: Vec<Value> = Vec::with_capacity(stats_map.len());
    for (fid, v) in stats_map.into_iter() {
        let total = v.get("total_time").and_then(|x| x.as_f64()).unwrap_or(0.0);
        let children = v.get("children_time").and_then(|x| x.as_f64()).unwrap_or(0.0);
        let call_count = v.get("call_count").and_then(|x| x.as_u64()).unwrap_or(0) as u64;
        let min_time = v.get("min_time").and_then(|x| x.as_f64()).unwrap_or(0.0);
        let max_time = v.get("max_time").and_then(|x| x.as_f64()).unwrap_or(0.0);
        let exclusive = total - children;
        let avg_time = if call_count > 0 { total / (call_count as f64) } else { 0.0 };

        nodes.push(serde_json::json!({
            "id": fid,
            "total_time": total,
            "call_count": call_count,
            "children_time": children,
            "exclusive_time": exclusive,
            "min_time": if min_time.is_infinite() { 0.0 } else { min_time },
            "max_time": max_time,
            "avg_time": avg_time
        }));
    }

    nodes.sort_by(|a, b| {
        b.get("total_time")
            .and_then(|x| x.as_f64())
            .partial_cmp(&a.get("total_time").and_then(|x| x.as_f64()))
            .unwrap_or(std::cmp::Ordering::Equal)
    });

    let mut edge_list = raw
        .get("edges")
        .and_then(|v| v.as_array())
        .cloned()
        .unwrap_or_default();

    edge_list.sort_by(|a, b| {
        b.get("total_time")
            .and_then(|x| x.as_f64())
            .partial_cmp(&a.get("total_time").and_then(|x| x.as_f64()))
            .unwrap_or(std::cmp::Ordering::Equal)
    });

    let total_functions = nodes.len();
    let total_calls: u64 = nodes
        .iter()
        .map(|n| n.get("call_count").and_then(|x| x.as_u64()).unwrap_or(0))
        .sum();

    let peak_tracemalloc = raw
        .get("peak_tracemalloc")
        .and_then(|x| x.as_u64())
        .or_else(|| raw.get("peak_tracemalloc").and_then(|x| x.as_f64()).map(|f| f as u64));

    let final_gc_counts = raw
        .get("final_gc_counts")
        .and_then(|x| x.as_array())
        .cloned()
        .unwrap_or_default();

    let total_gc_collections = raw
        .get("total_gc_collections")
        .and_then(|x| x.as_u64())
        .unwrap_or(0);

    let summary = serde_json::json!({
        "total_functions": total_functions,
        "total_calls": total_calls,
        "peak_memory_tracemalloc": peak_tracemalloc,
        "final_gc_counts": final_gc_counts,
        "total_gc_collections": total_gc_collections
    });

    let report = serde_json::json!({
        "meta": raw.get("meta").cloned().unwrap_or(serde_json::json!({
            "language": "python",
            "command": [target_script],
            "timestamp": chrono::Utc::now().timestamp(),
        })),
        "nodes": nodes,
        "edges": edge_list,
        "memory_samples": raw.get("memory_samples").cloned().unwrap_or_default(),
        "cpu_samples": raw.get("cpu_samples").cloned().unwrap_or_default(),
        "gc_samples": raw.get("gc_samples").cloned().unwrap_or_default(),
        "peak_rss": raw.get("peak_rss").cloned().unwrap_or(serde_json::Value::Null),
        "summary": summary
    });

    let report_json_path = report_dir.join("report.json");
    fs::write(&report_json_path, serde_json::to_string_pretty(&report)?)?;

    let template_path = exe_dir.join("../../src/html/reportTemplate.html");
    let html_report_path = report_dir.join("report.html");

    match fs::read_to_string(&template_path) {
        Ok(template_code) => {
            let mut wrapper = serde_json::Map::new();
            wrapper.insert("report".to_string(), report.clone());
            let wrapper_value = serde_json::Value::Object(wrapper);

            let ctx = TeraContext::from_serialize(&wrapper_value)
                .context("failed to serialize report into Tera context")?;

            let rendered = tera::Tera::one_off(&template_code, &ctx, true)
                .context(format!("failed to render template at {}", template_path.display()))?;
            fs::write(&html_report_path, rendered)?;
            println!("Rendered HTML using template: {}", template_path.display());

            let exe_dir_buf = exe_dir.to_path_buf();
            let template_dir = template_path.parent().unwrap_or(exe_dir_buf.as_path());
            let css_src = template_dir.join("report.css");
            let css_dst = report_dir.join("report.css");
            if css_src.exists() {
                if let Err(e) = fs::copy(&css_src, &css_dst) {
                    eprintln!(
                        "warning: failed to copy CSS {} -> {} : {}",
                        css_src.display(),
                        css_dst.display(),
                        e
                    );
                } else {
                    println!("Copied CSS to {}", css_dst.display());
                }
            } else {
                println!("No report.css next to template; no stylesheet copied.");
            }
        }
        Err(_) => {
            let html = format!(
                "<!doctype html><html><head><meta charset='utf-8'><title>Profile Report</title></head><body><pre>{}</pre></body></html>",
                serde_json::to_string_pretty(&report)?
            );
            fs::write(&html_report_path, html)?;
            println!("Template not found. Wrote fallback HTML: {}", html_report_path.display());
        }
    }


    println!("\nProfiling complete!");
    println!("Reports generated:");
    println!("   - JSON: {}", report_json_path.display());
    println!("   - HTML: {}", html_report_path.display());
    println!();
    println!("Open report.html in your browser to view the interactive report");

    Ok(())
}
